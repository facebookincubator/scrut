"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[175],{28453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>c});var t=n(96540);const r={},i=t.createContext(r);function o(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:s},e.children)}},59468:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"reference/fundamentals/shell-expression","title":"Shell Expressions","description":"At the core of any Scrut test case is a command line that is being tested. It can be a single command, a sequence of commands spanning multiple lines or anything else could possibly be written or pasted on the command line and executed. This command line is called a shell expression.","source":"@site/docs/reference/fundamentals/shell-expression.md","sourceDirName":"reference/fundamentals","slug":"/reference/fundamentals/shell-expression","permalink":"/scrut/docs/reference/fundamentals/shell-expression","draft":false,"unlisted":false,"editUrl":"https://www.internalfb.com/code/fbsource/fbcode/clifoundation/scrut/website/docs/reference/fundamentals/shell-expression.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Output Expectations","permalink":"/scrut/docs/reference/fundamentals/output-expectations"},"next":{"title":"Test Case","permalink":"/scrut/docs/reference/fundamentals/test-case"}}');var r=n(74848),i=n(28453);const o={},c="Shell Expressions",a={},l=[{value:"Constraints",id:"constraints",level:2},{value:"Returned Exit Code",id:"returned-exit-code",level:3},{value:"Detached Processes",id:"detached-processes",level:3}];function d(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"shell-expressions",children:"Shell Expressions"})}),"\n",(0,r.jsxs)(s.p,{children:["At the core of any Scrut ",(0,r.jsx)(s.a,{href:"/docs/reference/fundamentals/test-case/",children:"test case"})," is a command line that is being tested. It can be a single command, a sequence of commands spanning multiple lines or anything else could possibly be written or pasted on the command line and executed. This command line is called a ",(0,r.jsx)(s.em,{children:"shell expression"}),"."]}),"\n",(0,r.jsx)(s.p,{children:"All of the following are valid shell expressions:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ date\n$ echo Hello World\n$ date && echo Hello World\n$ function foo() { echo Hello World; }; foo\n$ cat foo | grep bar | wc -l\n$ function foo() { echo Hello World; }; \\\n  foo | \\\n  grep Hello | \\\n  wc -l\n"})}),"\n",(0,r.jsx)(s.p,{children:"The rule of thumb is: If you can paste and excecute it in the shell, then it is a valid shell expression."}),"\n",(0,r.jsx)(s.h2,{id:"constraints",children:"Constraints"}),"\n",(0,r.jsxs)(s.p,{children:["For the sake of understanding assume that each shell expression is written to a file and this file is then executed with ",(0,r.jsx)(s.code,{children:"bash"}),". Like so:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ echo 'echo My shell expression' > shell-expression.sh\n$ bash shell-expression.sh\nMy shell expression\n"})}),"\n",(0,r.jsx)(s.admonition,{type:"note",children:(0,r.jsxs)(s.p,{children:["Learn about the how execution works in ",(0,r.jsx)(s.a,{href:"/docs/reference/behavior/execution-model/",children:"Reference > Behavior > Execution Model"}),"."]})}),"\n",(0,r.jsx)(s.p,{children:"This behavior implies some limits / constraints on what you can expect from the result:"}),"\n",(0,r.jsx)(s.h3,{id:"returned-exit-code",children:"Returned Exit Code"}),"\n",(0,r.jsxs)(s.p,{children:["Consider the following ",(0,r.jsx)(s.a,{href:"/docs/reference/fundamentals/shell-expression/",children:"shell expression"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"$ false ; true\n"})}),"\n",(0,r.jsxs)(s.p,{children:["This executes the command ",(0,r.jsx)(s.code,{children:"false"})," and then executes the command ",(0,r.jsx)(s.code,{children:"true"}),". They are both separated by a ",(0,r.jsx)(s.code,{children:";"}),", which makes them individual commands from the ",(0,r.jsx)(s.code,{children:"bash"})," perspective. If you would have a bash script file with these contents and would execute it, then you would see the exit code ",(0,r.jsx)(s.code,{children:"0"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ echo 'false ; true' > shell-expression.sh\n$ bash shell-expression.sh\n$ echo $?\n0\n"})}),"\n",(0,r.jsxs)(s.p,{children:["That means the exit code of ",(0,r.jsx)(s.code,{children:"false"})," (which is ",(0,r.jsx)(s.code,{children:"1"}),") is not surfaced, because the shell script itself continues to the next command (",(0,r.jsx)(s.code,{children:"true"}),"). The returned exit code is simply the exit code of the last command in the shell script."]}),"\n",(0,r.jsxs)(s.p,{children:["If this behavior is not desired (it may be), then you could use the ",(0,r.jsx)(s.code,{children:"&&"})," operator instead of ",(0,r.jsx)(s.code,{children:";"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ echo 'false && true' > shell-expression.sh\n$ bash shell-expression.sh\n$ echo $?\n1\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Alternatively, as these are bash scripts, you can also use the ",(0,r.jsx)(s.code,{children:"set -e"})," directive to make the shell script exit on the first non-zero exit code:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ echo 'set -e ; false ; true' > shell-expression.sh\n$ bash shell-expression.sh\n$ echo $?\n1\n"})}),"\n",(0,r.jsx)(s.admonition,{type:"warning",children:(0,r.jsxs)(s.p,{children:["Due to the different ",(0,r.jsx)(s.a,{href:"/docs/reference/behavior/execution-model/",children:"execution model of Cram"})," using ",(0,r.jsx)(s.code,{children:"set -e"})," will terminate not only the ",(0,r.jsx)(s.a,{href:"/docs/reference/fundamentals/test-case/",children:"test case"}),", but all ",(0,r.jsx)(s.a,{href:"/docs/reference/fundamentals/test-case/",children:"test cases"})," in the same ",(0,r.jsx)(s.a,{href:"/docs/reference/fundamentals/test-document/",children:"test document"}),". Do not use it."]})}),"\n",(0,r.jsx)(s.h3,{id:"detached-processes",children:"Detached Processes"}),"\n",(0,r.jsxs)(s.p,{children:["When Scrut runs a shell expression it will wait for the execution to finish, so that it can gather the exit code and the output and validate it as defined by the ",(0,r.jsx)(s.a,{href:"/docs/reference/fundamentals/test-case/",children:"test case"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["However, if the shell expression detaches from the shell, or spawns processes that are detached (or both) then Scrut will not wait for them. ",(0,r.jsx)(s.strong,{children:"Scrut will not manage their lifetime at all."})]}),"\n",(0,r.jsxs)(s.admonition,{type:"tip",children:[(0,r.jsxs)(s.p,{children:["If you need to test a server/client scenario, where first a server must be started and before the CLI ",(0,r.jsx)(s.a,{href:"/docs/reference/fundamentals/test-case/",children:"test cases"})," can execute then have a look at the ",(0,r.jsxs)(s.a,{href:"/docs/reference/fundamentals/inline-configuration/#wait-configuration",children:[(0,r.jsx)(s.code,{children:"detached"}),"/",(0,r.jsx)(s.code,{children:"wait"})," configuration directives"]}),"."]}),(0,r.jsxs)(s.p,{children:["Here the ",(0,r.jsx)(s.code,{children:"detached_kill_signal"})," can be specified to send a user-definedable signal to the detached process to terminate it. ",(0,r.jsx)(s.strong,{children:"Note that Scrut will only send the signal, it is up to the process to handle it correctly."})]})]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);