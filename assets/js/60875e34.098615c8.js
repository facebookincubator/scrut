"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[9661],{23476:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"tutorial","title":"Tutorial","description":"A walkthrough of Scrut use from start to end. For in-depth information: follow the white rabbit inline links.","source":"@site/docs/tutorial.md","sourceDirName":".","slug":"/tutorial","permalink":"/scrut/docs/tutorial","draft":false,"unlisted":false,"editUrl":"https://www.internalfb.com/code/fbsource/fbcode/clifoundation/scrut/website/docs/tutorial.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Scrut","permalink":"/scrut/docs/"},"next":{"title":"File Formats","permalink":"/scrut/docs/advanced/file-formats"}}');var i=n(74848),o=n(28453);const r={sidebar_position:2},a="Tutorial",h={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"About file structure",id:"about-file-structure",level:3},{value:"Decide what to test first",id:"decide-what-to-test-first",level:2},{value:"Pattern: Automatic Test Creation",id:"pattern-automatic-test-creation",level:2},{value:"Run the first Test",id:"run-the-first-test",level:3},{value:"Pattern: Resilient Tests",id:"pattern-resilient-tests",level:2},{value:"Pattern: Test Fixtures",id:"pattern-test-fixtures",level:2},{value:"Tests directory isolation",id:"tests-directory-isolation",level:3},{value:"Pattern: Test Bootstrapping",id:"pattern-test-bootstrapping",level:2},{value:"Bootstrapping, sounds familiar?",id:"bootstrapping-sounds-familiar",level:3},{value:"Pattern: Update as a Workflow",id:"pattern-update-as-a-workflow",level:2},{value:"Powerful Expectations",id:"powerful-expectations",level:2},{value:"Glob",id:"glob",level:3},{value:"Regular expression",id:"regular-expression",level:3},{value:"Quantifiers",id:"quantifiers",level:3},{value:"Pattern: Structure by use-case",id:"pattern-structure-by-use-case",level:2},{value:"Next steps",id:"next-steps",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"tutorial",children:"Tutorial"})}),"\n",(0,i.jsxs)(t.p,{children:["A walkthrough of Scrut use from start to end. For in-depth information: follow the ",(0,i.jsx)(t.del,{children:"white rabbit"})," inline links."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["The beginning is perhaps more difficult than anything else, but keep heart, it will turn out all right. - ",(0,i.jsx)(t.em,{children:"Vincent van Gogh"})]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This guide is written with the following target audiences in mind:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"CLI owners / contributors"}),", that care about the quality of a specific CLI and therefore want to","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Prove the behavior of the CLI in the form of integration / end-to-end tests tests"}),"\n",(0,i.jsx)(t.li,{children:"Document the CLI behavior for themselves of future developers of the CLI"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"System administrators / operators"}),", that care about the CLI tools they work with and need to","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Establish understanding and verify assumptions about their CLI tools"}),"\n",(0,i.jsx)(t.li,{children:"Document behavior of their CLI tools for themselves or future generations"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(t.p,{children:["To make it very simple to follow along, this guide uses the modern, but well established ",(0,i.jsx)(t.a,{href:"https://github.com/jqlang/jq",children:(0,i.jsx)(t.code,{children:"jq"})})," command line tool as the CLI that is tested in all provided code examples. Deep understanding of ",(0,i.jsx)(t.code,{children:"jq"})," is not required, but it would help if you have at least some grasp what it does and how to use it. If that is not the case, yet: it is a truly, amazingly useful tool; now is a great time to learn about!"]}),"\n",(0,i.jsx)(t.p,{children:"The following should work on your terminal:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sh",children:"# scrut itself should be installed\n$ scrut --version\nscrut 0.2.0\n\n# jq should be installed\n$ jq --version\njq-1.6\n"})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),": In all shell code blocks within this document lines prefixed with ",(0,i.jsx)(t.code,{children:"$ "})," are commands, lines prefixed with ",(0,i.jsx)(t.code,{children:"# "})," are comments and any other line can be assumed to be the output of the previous command"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"about-file-structure",children:"About file structure"}),"\n",(0,i.jsxs)(t.p,{children:["Scrut does not require any particular file structure. This tutorial is assuming that the files would be stored in a ",(0,i.jsx)(t.code,{children:"integration-tests"})," subdirectory together with the source-code of the CLI that is tested."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"# going to the directory that contains the source code\n$ cd ~/Projects/jq\n\n# creating a new directory that is going to contain the tests\n$ mkdir integration-tests\n"})}),"\n",(0,i.jsx)(t.p,{children:"Although Scrut has no requirements towards file structure it is recommended, that all test relating files (see more below) are in the same directory as the test files themselves, which makes referencing them easier."}),"\n",(0,i.jsx)(t.h2,{id:"decide-what-to-test-first",children:"Decide what to test first"}),"\n",(0,i.jsxs)(t.p,{children:["What then is the first thing to test about our CLI ",(0,i.jsx)(t.code,{children:"jq"}),"? What is the first thing to test about any CLI? Maybe you have a great answer that fits perfectly for your specific CLI. If you don't then consider to start with a ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Smoke_testing_(software)",children:"smoke test"}),": ",(0,i.jsx)(t.em,{children:"When I switch it on, do I see smoke rising up?"})]}),"\n",(0,i.jsxs)(t.p,{children:["Translated to a CLI that means: executing the tool in the most basic way possible, does it panic / fatal / die unexpectedly? Considering you keep developing your CLI, such a basic test answers the question: ",(0,i.jsx)(t.em,{children:"Did you break something very fundamental?"})]}),"\n",(0,i.jsxs)(t.p,{children:["And what would be a good smoke test for a CLI? For ",(0,i.jsx)(t.code,{children:"jq"})," it is the execution from above (",(0,i.jsx)(t.code,{children:"jq --version"}),") seems like a great candidate. For other CLIs it might be ",(0,i.jsx)(t.code,{children:"--help"})," instead. Either way, you want to choose something that doesn't have much complexity, that doesn't rely on any external dependencies. If you are the author of the CLI that should be easy to find."]}),"\n",(0,i.jsx)(t.h2,{id:"pattern-automatic-test-creation",children:"Pattern: Automatic Test Creation"}),"\n",(0,i.jsx)(t.p,{children:"Finally, let's get to writing the test. Actually writing seems too bothersome. Sure, you could, but how about you generate it instead? Do that:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"$ scrut create --output integration-tests/smoke.md -- jq --version\nWriting generated test to `integration-tests/smoke.md`\n"})}),"\n",(0,i.jsx)(t.p,{children:"Ok, let me unpack that for you:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"scrut create"})," - tells Scrut to execute a command and create a test from its output"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"--output integration-tests/smoke.md"})," - lets ",(0,i.jsx)(t.code,{children:"scrut"})," know where to write the created test to"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"--"})," - signifies the end of options for scrut; all that follows is part of the command for which a test is generated"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"jq --version"})," - that is the command (the ",(0,i.jsx)(t.em,{children:"Shell Expression"}),") which ",(0,i.jsx)(t.code,{children:"scrut"})," is going to execute and from which's output it is going to generate test ",(0,i.jsx)(t.em,{children:"Expectations"})]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This also could have been written differently:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:'$ echo "jq --version" | scrut create - > integration-tests/smoke.md\nWriting generated test to STDOUT\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Here the string ",(0,i.jsx)(t.code,{children:"jq --version"})," was piped to the STDIN of ",(0,i.jsx)(t.code,{children:"scrut create"})," (which was made aware of that by having one argument ",(0,i.jsx)(t.code,{children:"-"}),") and the output (to STDOUT) was delegated into the same output file as before."]}),"\n",(0,i.jsxs)(t.p,{children:["Both are valid forms and result in the same outcome, that is a new test in the file ",(0,i.jsx)(t.code,{children:"integration-tests/smoke.md"}),". The contents of that file should be like that (aside from the version string, that is likely different for you):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:"# Command executes successfully\n\n```scrut\n$ jq --version\njq-1.6\n```\n"})}),"\n",(0,i.jsxs)(t.p,{children:["While you are looking at it, how about you change that title to ",(0,i.jsx)(t.code,{children:"Smoke test"})," or something like that. ",(0,i.jsx)(t.strong,{children:"Half of the value of a Scrut test file is the documentation, so it is always worth to put in some time to clarify intentions and describe expectations"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Don't touch the rest - for now. We'll get to that in a minute. You can read up on the ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/file-formats#file-anatomy",children:"anatomy of the file"}),", here a very quick primer:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Scrut test files are ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/file-formats#markdown-format",children:"markdown documents"})]}),"\n",(0,i.jsxs)(t.li,{children:["Code blocks of language ",(0,i.jsx)(t.code,{children:"scrut"})," contain the tested commands and the expected output"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"run-the-first-test",children:"Run the first Test"}),"\n",(0,i.jsx)(t.p,{children:"Running tests is the bread and butter of Scrut. It is - literally - what it is made for. So without further ado:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"$ scrut test integration-tests/smoke.md\nValidation succeeded\n"})}),"\n",(0,i.jsx)(t.p,{children:"Nice! That works. As it should be, since Scrut create the test for you. Although that was a bit anticlimactic. Let's make it more fun and go break it \ud83e\udd21. Change the contents of the file like so:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:"# Smoke test\n\n```scrut\n$ jq --version\nfoo\n```\n"})}),"\n",(0,i.jsx)(t.p,{children:"Now run it again:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"$ scrut test integration-tests/smoke.md\n// =============================================================================\n// @ integration-tests/smoke.md\n// -----------------------------------------------------------------------------\n// # Smoke test\n// -----------------------------------------------------------------------------\n// $ jq --version\n// =============================================================================\n\n1     | - foo\n   1  | + jq-1.6\n"})}),"\n",(0,i.jsx)(t.p,{children:"Ok, it is getting interesting. What you are seeing here (likely in color) is an output validation error. The output expectations in the test file do not match with the output the command actually spits out. This is how you read it:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"@ integration-tests/smoke.md"}),": Location of the test file"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"# Smoke test"}),": Title of the test in the file"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$ task --version"}),": Shell expression that resulted in invalid output"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"1     | - foo\n   1  | + jq-1.6\n"})}),"\n","The first line ",(0,i.jsx)(t.code,{children:"1 | - foo"})," denotes that ",(0,i.jsx)(t.code,{children:"foo"})," was expected from the test, but is missing in the output. The next line ",(0,i.jsx)(t.code,{children:"1 | + jq-1.6"})," denotes that ",(0,i.jsx)(t.code,{children:"jq-1.6"})," was printed out as 1st line from the command, but is missing in the test."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"pattern-resilient-tests",children:"Pattern: Resilient Tests"}),"\n",(0,i.jsxs)(t.p,{children:["This is actually a good point in time to speak about brittle tests. Having the version (here ",(0,i.jsx)(t.code,{children:"jq-1.6"}),") in the ",(0,i.jsx)(t.code,{children:"smoke.md"})," file is not a good idea. Why? Because it is likely to change, because you keep developing it. Or someone is. Having that string in the test file will just create the worst kind of all work down the line: toil."]}),"\n",(0,i.jsx)(t.p,{children:"Also consider: Does having the version in there really provide value? The idea of the smoke test is to fail if things are so broken, that basically nothing works anymore. From that perspective, there is no need to check about the version: let's get rid of this nascent technical debt."}),"\n",(0,i.jsx)(t.p,{children:"So how do you do that? Well, how would you do it on the shell? You would do something like that:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sh",children:"$ jq --version > /dev/null\n"})}),"\n",(0,i.jsx)(t.p,{children:"And that is exactly how you would do it in the test:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:"# Smoke test\n\n```scrut\n$ jq --version > /dev/null\n```\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Is that still a meaningful test? Yes, it is! It still tests whether the command executes successfully. What does successfully mean? Well, whether it exits with a ",(0,i.jsx)(t.code,{children:"0"})," exit code. ",(0,i.jsx)(t.em,{children:"That is an implicit test any test case will automatically provide"}),". Don't take my word for it, though. Change the expected exit code to, say, ",(0,i.jsx)(t.code,{children:"10"})," and see what happens. Just add a new line containing ",(0,i.jsx)(t.code,{children:"[10]"})," after the shell expression:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:"# Smoke test\n\n```scrut\n$ jq --version > /dev/null\n[10]\n```\n"})}),"\n",(0,i.jsx)(t.p,{children:"Now test it:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"$ scrut test integration-tests/smoke.md\n// =============================================================================\n// @ integration-tests/smoke.md\n// -----------------------------------------------------------------------------\n// # Smoke test\n// -----------------------------------------------------------------------------\n// $ jq --version > /dev/null\n// =============================================================================\n\nunexpected exit code\n  expected: 10\n  actual:   0\n\n## STDOUT\n## STDERR\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As promised: it fails. The output should be self explanatory. Read more about ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/specifics#exit-codes",children:"exit codes here"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Going forward remove the ",(0,i.jsx)(t.code,{children:"[10]"})," again, so that the test is in a working state."]}),"\n",(0,i.jsx)(t.h2,{id:"pattern-test-fixtures",children:"Pattern: Test Fixtures"}),"\n",(0,i.jsxs)(t.p,{children:["Ok, let's start with testing actual functionality. No worries, we won't attempt to cover all that ",(0,i.jsx)(t.code,{children:"jq"})," can do with tests in this tutorial. Just enough to show some good to know patterns. Here is one, if a bit obvious: a good idea to start with any test is executing it on the shell."]}),"\n",(0,i.jsxs)(t.p,{children:["Since ",(0,i.jsx)(t.code,{children:"jq"})," is a neat tool to manipulate JSON, we need some JSON to manipulate. Let's use the ",(0,i.jsxs)(t.a,{href:"https://jqlang.github.io/jq/tutorial/",children:["same as the ",(0,i.jsx)(t.code,{children:"jq"})," tutorial itself"]}),", that is the Github history of ",(0,i.jsxs)(t.a,{href:"https://github.com/jqlang/jq",children:["the ",(0,i.jsx)(t.code,{children:"jq"})," repository"]}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sh",children:"$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5'\n# not gonna show the output, it is a lot\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Let's say we want to write a test that proves and documents the (imho) core functionality of ",(0,i.jsx)(t.code,{children:"jq"}),": mutating JSON. As an example we are going to reduce those huge JSON dumps into something more manageable: ",(0,i.jsx)(t.em,{children:"who's commit was committed when"}),". Each result item should have the following form: ",(0,i.jsx)(t.code,{children:'{"who": "<name>", "when": "<date>"} '}),". This is how you can achieve that on the the command line (names changed):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sh",children:'$ curl \'https://api.github.com/repos/jqlang/jq/commits?per_page=5\' | \\\n  jq \'[.[] | {who: .commit.author.name, when: .commit.committer.date}]\'\n[\n  {\n    "who": "Person Name",\n    "when": "2022-05-26T21:04:32Z"\n  },\n  {\n    "who": "Another Person",\n    "when": "2022-05-26T21:02:50Z"\n  },\n  {\n    "who": "Even More",\n    "when": "2022-05-26T21:02:10Z"\n  },\n  {\n    "who": "And so forth",\n    "when": "2022-05-26T21:01:25Z"\n  },\n  {\n    "who": "Name Name",\n    "when": "2022-05-26T20:53:59Z"\n  }\n]\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Ok, that shows that the transformation of the output works as we assumed it would. However, you probably have noted, using the ",(0,i.jsx)(t.code,{children:"curl"})," output in the a test will not be very resilient, as the output is prone to change."]}),"\n",(0,i.jsxs)(t.p,{children:["Since we are not really interested in the functionality of ",(0,i.jsx)(t.code,{children:"curl"})," or Github (and quite frankly could without network dependencies), let's instead store the current output of the ",(0,i.jsx)(t.code,{children:"curl"})," execution into a ",(0,i.jsx)(t.em,{children:"test fixture file"})," in our ",(0,i.jsx)(t.code,{children:"integration-tests"})," folder. This way we have a consistent input to run our test on:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sh",children:"$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' > integration-tests/commits.json\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now we can start with writing the actual test file. Instead of using ",(0,i.jsx)(t.code,{children:"scrut create"}),", start with the following template in ",(0,i.jsx)(t.code,{children:"integration-tests/transform-input.md"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:'# Transform input\n\n```scrut\n$ cat "$TESTDIR/commits.json" | \\\n> jq \'[.[] | {who: .commit.author.name, when: .commit.committer.date}]\'\n[\n  {\n    "who": "Person Name",\n    "when": "2022-05-26T21:04:32Z"\n  },\n  {\n    "who": "Another Person",\n    "when": "2022-05-26T21:02:50Z"\n  },\n  {\n    "who": "Even More",\n    "when": "2022-05-26T21:02:10Z"\n  },\n  {\n    "who": "And so forth",\n    "when": "2022-05-26T21:01:25Z"\n  },\n  {\n    "who": "Name Name",\n    "when": "2022-05-26T20:53:59Z"\n  }\n]\n```\n'})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),": The second (and any subsequent) line of a command starts with a ",(0,i.jsx)(t.code,{children:">"})," character - unlike the first, which starts with a ",(0,i.jsx)(t.code,{children:"$"})," (",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/file-formats#markdown-format",children:"read more"}),"). The tailing ",(0,i.jsx)(t.code,{children:"\\\\"})," in the first command line is needed, because ",(0,i.jsx)(t.code,{children:"/bin/bash"})," needs it (both lines, stripped by their starting ",(0,i.jsx)(t.code,{children:"$"})," or ",(0,i.jsx)(t.code,{children:">"})," character, are ultimately passed to the shell process, hence must comply with it's requirements)."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"tests-directory-isolation",children:"Tests directory isolation"}),"\n",(0,i.jsxs)(t.p,{children:["You may have noted the that the ",(0,i.jsx)(t.code,{children:"commits.json"})," file is referred to as ",(0,i.jsx)(t.code,{children:'"$TESTDIR/commits.json"'}),". The reason for that is that each test is executed from within an empty test directory. The absolute path to the directory, where the actual test file is in is available via the ",(0,i.jsx)(t.code,{children:"$TESTDIR"})," environment variable. Since ",(0,i.jsx)(t.code,{children:"commits.json"})," is located in the same directory as ",(0,i.jsx)(t.code,{children:"transform-input.md"})," the expression ",(0,i.jsx)(t.code,{children:'"$TESTDIR/commits.json"'})," contains the absolute path to the ",(0,i.jsx)(t.code,{children:"commits.json"})," file (",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/specifics#test-environment-variables",children:"read more"}),")."]}),"\n",(0,i.jsx)(t.h2,{id:"pattern-test-bootstrapping",children:"Pattern: Test Bootstrapping"}),"\n",(0,i.jsxs)(t.p,{children:["There is one more thing that should be done to make the test resilient: ",(0,i.jsx)(t.code,{children:"jq"})," has a couple of command line parameters that decide how the output is being rendered. There are two in particular, which should be set in our case:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"-r"})," (raw output): Pertains to non-JSON output, in which strings would be quoted without it (let's not - easier to pipe into other command line programs)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"-M"})," (monochrome, not colored output): While that is currently the default, it may change which would break our test"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"-S"})," (sort keys of objects): Currently, the keys are outputted as we provided them - but to be safe (have a resilient test), lets just explicitly sort them, then there is no question in their order"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Using both of those keys would change the command in the ",(0,i.jsx)(t.code,{children:"jq <..>"})," command in the test to ",(0,i.jsx)(t.code,{children:"jq -r -M -S <..>"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Thinking ahead, we are going to use these flags in ",(0,i.jsx)(t.em,{children:"every test"}),", for the same reason why we are using it here (be very sure about the expected output). With that in mind, consider the following bash script:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"#/bin/bash\n\n# tell bash exporting aliases is fine\nshopt -s expand_aliases\n\n# alias `jq`, so that it always executes with the two parameters\nalias jq='jq -r -M -S'\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Store the above file under ",(0,i.jsx)(t.code,{children:"integration-tests/setup.sh"}),", and then we can make use of it in our test file:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:'# Test transformation\n\nTest whether `jq` transforms tests as we\n\n## Bootstrap\n\n```\n$ source "$TESTDIR/setup.sh"\n```\n\n## Transform input\n\n```scrut\n$ cat "$TESTDIR"/commits.json | \\\n> jq \'[.[] | {who: .commit.author.name, when: .commit.committer.date}]\'\n[\n  {\n    "when": "2022-05-26T21:04:32Z",\n    "who": "Person Name"\n  },\n  {\n    "when": "2022-05-26T21:02:50Z",\n    "who": "Another Person"\n  },\n  {\n    "when": "2022-05-26T21:02:10Z",\n    "who": "Even More"\n  },\n  {\n    "when": "2022-05-26T21:01:25Z",\n    "who": "And so forth"\n  },\n  {\n    "when": "2022-05-26T20:53:59Z",\n    "who": "Name Name"\n  }\n]\n```\n'})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),": The order of ",(0,i.jsx)(t.code,{children:"who"})," and ",(0,i.jsx)(t.code,{children:"when"})," changed due to ",(0,i.jsx)(t.code,{children:"-S"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["As you can see there are now two code blocks of the type ",(0,i.jsx)(t.code,{children:"scrut"})," in the same file. That means there are two tests in that one file. This is fine, you can have ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/file-formats#file-anatomy",children:"as many test as make sense to you in a file"}),". Scrut ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/specifics#test-execution",children:"executes them in order"}),", which allows the ",(0,i.jsx)(t.code,{children:"alias jq=.."})," set in ",(0,i.jsx)(t.code,{children:"setup.sh"})," to affect the ",(0,i.jsx)(t.code,{children:"jq"})," execution in the test file."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Bootstrapping tests is a very common strategy in Scrut"})," and is considered idiomatic."]}),"\n",(0,i.jsx)(t.h3,{id:"bootstrapping-sounds-familiar",children:"Bootstrapping, sounds familiar?"}),"\n",(0,i.jsxs)(t.p,{children:["If you are familiar with unit testing (in whatever language), you likely came across the ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Test_suite",children:"test suite pattern"}),". If not, then in (very) short: A test suite is a semantic cohesive collection of tests, which is often run against different implementations of the same interface. Imagine a storage backend interface, for which an implementation ",(0,i.jsx)(t.code,{children:"LocalStorage"})," writes on a local disk and ",(0,i.jsx)(t.code,{children:"RemoteStorage"})," writes somewhere in the cloud. Both implement the same ",(0,i.jsx)(t.code,{children:"Storage"})," interface and therefore can be tested by the same test suite ",(0,i.jsx)(t.code,{children:"StorageTestSuite"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:['In those scenarios it is not uncommon that each test-suite run executes specific "setup code" for each implementation, before all the tests are executed. You may often find methods named like ',(0,i.jsx)(t.code,{children:"setupTests"}),", ",(0,i.jsx)(t.code,{children:"beforeTests"})," or something akin."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"A variant of bootstrapping is seeding"})," where a specific methods are executed once before ",(0,i.jsx)(t.em,{children:"each"})," test (as oppose to: once before ",(0,i.jsx)(t.em,{children:"all"})," tests). Although the terms may be also be used interchangeable (depends on the language of the testing framework and developer's choice). Translated to Scrut you could have ",(0,i.jsx)(t.code,{children:"seed-some-state.sh"})," files, that are then included in one or multiple tests, to keep the tests themselves clean and the code d.r.y."]}),"\n",(0,i.jsx)(t.h2,{id:"pattern-update-as-a-workflow",children:"Pattern: Update as a Workflow"}),"\n",(0,i.jsx)(t.p,{children:"In the previous section quite a lot of copying from the terminal into text files happened. A tad bothersome and smells like a bad tedious process. Indeed. There is a better way."}),"\n",(0,i.jsxs)(t.p,{children:["Let's start with a new test. ",(0,i.jsx)(t.code,{children:"jq"})," has ",(0,i.jsx)(t.a,{href:"https://jqlang.github.io/jq/manual/#Builtinoperatorsandfunctions",children:"a lot of built-in functions"}),", so there is plenty to pick from. Since we were already interested in that committer date earlier, lets write a test for the ",(0,i.jsx)(t.code,{children:"fromdate"})," function. Start with the following template, which is basically a copy of the previous test, but with the new command we want and with all outputs striped:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:'# Test built-in `fromdate`\n\nAssure the `fromdate` function parses ISO 8601 dates into unix timestamps\n\n## Bootstrap\n\n```scrut\n$ source "$TESTDIR/setup.sh"\n```\n\n## Use `fromdate`\n\n```scrut\n$ cat "$TESTDIR"/commits.json | \\\n> jq \'.[] | .commit.committer.date | fromdate\'\n```\n'})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Having clear intentions in the leading markdown of a test file is a good practice"}),". Here it makes it clear that we are expecting the output of some unix timestamps. Since we don't have any, it is to be expected that the test execution will fail. Only one way to be sure:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"$ scrut test integration-tests/builtin-fromdate.md\n// =============================================================================\n// @ integration-tests/builtin-fromdate.md\n// -----------------------------------------------------------------------------\n// # Use `fromdate`\n// -----------------------------------------------------------------------------\n// $ cat \"$TESTDIR\"/commits.json | \\\n//   jq '.[] | .commit.committer.date | fromdate'\n// =============================================================================\n\n   1  | + 1653599072\n   2  | + 1653598970\n   3  | + 1653598930\n   4  | + 1653598885\n   5  | + 1653598439\n"})}),"\n",(0,i.jsx)(t.p,{children:"This output tells us two things:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["It seems ",(0,i.jsx)(t.code,{children:"fromdate"})," can parse our dates and transform them into unix timestamps"]}),"\n",(0,i.jsx)(t.li,{children:"The test fails, because it does not mention the expected output"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"At least the latter is not completely surprising. In order to make the test green, we could again copy the output into the test. However, there is a better way - as promised:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"$ scrut update --replace integration-tests/builtin-fromdate.md\n"})}),"\n",(0,i.jsx)(t.p,{children:"This shows you the same failed test output again. However, in addition it ends in a prompt that asks you whether the test file should be overwritten:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"> Overwrite existing file `integration-tests/builtin-fromdate.md`?\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Hit ",(0,i.jsx)(t.code,{children:"y"})," here, which will cause ",(0,i.jsx)(t.code,{children:"scrut"})," to update your test and add the missing output lines after the command for you."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Writing tests and using update to fill in the outputs is good practice"})," for creating new tests and also for maintain existing ones: Imagine you fix a typo in the command output. Run ",(0,i.jsx)(t.code,{children:"scrut update <file>"})," to fix the test. Does the typo change a lot of tests? Run ",(0,i.jsx)(t.code,{children:"scrut update <directory>"})," and be done."]}),"\n",(0,i.jsx)(t.h2,{id:"powerful-expectations",children:"Powerful Expectations"}),"\n",(0,i.jsxs)(t.p,{children:["Take a step back and consider the test cases we wrote so far - and compare them against real-live scenarios. One thing may peak out you: Using a the ",(0,i.jsx)(t.code,{children:"commits.json"})," file as a test fixture is a neat way to assure that we always work on the same input data. However, especially in the end-2-end testing space, things are not always possible. Things are not as neat and tidy."]}),"\n",(0,i.jsxs)(t.p,{children:["Leave the idea of testing the functionality of ",(0,i.jsx)(t.code,{children:"jq"})," for a moment behind, so you can think about writing tests for situations where the data your tests run on is outside of your control."]}),"\n",(0,i.jsxs)(t.p,{children:["Let's revisit our ",(0,i.jsx)(t.code,{children:"transform-input.md"})," test file from before. Copy it into ",(0,i.jsx)(t.code,{children:"transform-input-live.md"})," and change in that new file the command into the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:"```scrut\n$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | \\\n> jq '.[] | .commit.author.name + \";\" + .commit.committer.date'\n```\n"})}),"\n",(0,i.jsxs)(t.p,{children:['This means: we are back to using the live data (to simulate "dirty" / unpredictable data). Also the output is no longer JSON, but a single line string per commit with the format ',(0,i.jsx)(t.code,{children:"<name>;<date>"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["First, run ",(0,i.jsx)(t.code,{children:"scrut update"})," on it and overwrite the contents. The modified ",(0,i.jsx)(t.code,{children:"transform-input-live.md"})," file should look something like that (with different names and dates):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:"# Test transformation\n\n## Bootstrap\n\n```scrut\n$ source \"$TESTDIR/setup.sh\"\n```\n\n## Transform input from live data\n\n```scrut\n$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | \\\n> jq '.[] | .commit.author.name + \";\" + .commit.committer.date'\nPerson Name;2022-05-26T21:04:32Z\nAnother Person;2022-05-26T21:02:50Z\nEven More;2022-05-26T21:02:10Z\nAnd so forth;2022-05-26T21:01:25Z\nName Name;2022-05-26T20:53:59Z\n```\n"})}),"\n",(0,i.jsx)(t.p,{children:"We already established, that having this specific content in there is brittle and will cause headache down the line. So where is this going?"}),"\n",(0,i.jsxs)(t.p,{children:["At this point it becomes necessary to understand that each of the output lines in the test are actually ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/expectations",children:"output expectations"}),". The last line of the above output could also be written as:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Name Name;2022-05-26T20:53:59Z (equal)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The tailing ",(0,i.jsx)(t.code,{children:" (equal)"})," is the ",(0,i.jsx)(t.em,{children:"type"}),", telling Scrut that this is, well, an expectation which should match exactly the provided expression (like the ",(0,i.jsx)(t.code,{children:"=="})," equal operator). Since those are the most common ones, and it is so much more readable to ",(0,i.jsx)(t.em,{children:"not"})," have ",(0,i.jsx)(t.code,{children:"(equal)"})," everywhere, you can omit it. However, this the only expectation that allows you to omit the type."]}),"\n",(0,i.jsx)(t.h3,{id:"glob",children:"Glob"}),"\n",(0,i.jsxs)(t.p,{children:["Scrut has two expectation types that would work here. Lets start with simpler one, that is powerful, but not very precise, though easy to write and read. It is the ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/expectations#glob-expectation",children:"glob expectation"}),". Consider the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:"## Transform input from live data\n\n```scrut\n$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | \\\n> jq '.[] | .commit.author.name + \";\" + .commit.committer.date'\n*;20*Z (glob)\n*;20*Z (glob)\n*;20*Z (glob)\n*;20*Z (glob)\n*;20*Z (glob)\n```\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Without going ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/expectations#glob-expectation",children:"into full detail"}),", glob supports two wildcard characters ",(0,i.jsx)(t.code,{children:"*"})," for any amount of any character and ",(0,i.jsx)(t.code,{children:"?"})," for a single arbitrary character. Each of the above expectations translates to:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Any string that is followed by ",(0,i.jsx)(t.code,{children:";20"})]}),"\n",(0,i.jsx)(t.li,{children:"Followed by anything"}),"\n",(0,i.jsxs)(t.li,{children:["Ending in ",(0,i.jsx)(t.code,{children:"Z"})]}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),": ",(0,i.jsx)(t.em,{children:"anything"})," means anything ",(0,i.jsx)(t.em,{children:"but"})," a newline character"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Using the glob expectation like this should cover about any possible output - at least until the year 2100. There should be little maintenance in the short- to midterm. That is reasonable resilient - but rather imprecise."}),"\n",(0,i.jsxs)(t.p,{children:["On that note: As you can see, we repeated the same expectation five times. ",(0,i.jsx)(t.strong,{children:"Each line of output must have a matching expectation or the test fails"}),". That also means: Having exactly five expectations is a test in itself, which would fail for zero or four or six lines of outputs equally."]}),"\n",(0,i.jsx)(t.h3,{id:"regular-expression",children:"Regular expression"}),"\n",(0,i.jsx)(t.p,{children:"The above headline bestows fear in many and delight in some. So it is up to you to read this paragraph or skip it entirely. If you are not familiar with regular expressions, maybe you take this as an opportunity to learn about them - although this is way beyond the scope of this how-to."}),"\n",(0,i.jsxs)(t.p,{children:["Lets jump right into it then: ",(0,i.jsx)(t.code,{children:"scrut"})," supports ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/expectations#regex-expectation",children:"regular expression expectations"})," with the ",(0,i.jsx)(t.code,{children:" (regex)"})," type. Rewriting the test from above could look like that (well, one variant):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:"## Transform input from live data\n\n```scrut\n$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | \\\n> jq '.[] | .commit.author.name + \";\" + .commit.committer.date'\n\\w+(?:\\s\\w+)*;\\d{4}\\-\\d{2}\\-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z (regex)\n\\w+(?:\\s\\w+)*;\\d{4}\\-\\d{2}\\-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z (regex)\n\\w+(?:\\s\\w+)*;\\d{4}\\-\\d{2}\\-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z (regex)\n\\w+(?:\\s\\w+)*;\\d{4}\\-\\d{2}\\-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z (regex)\n\\w+(?:\\s+\\w+)*;\\d{4}\\-\\d{2}\\-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z (regex)\n```\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This is much more precise than the above glob expectation - at the cost of readability. There is room for error, that likely won't capture all possible name writings (e.g. ",(0,i.jsx)(t.code,{children:"Forename M. Surname"})," would fail) - feel free to optimize."]}),"\n",(0,i.jsx)(t.h3,{id:"quantifiers",children:"Quantifiers"}),"\n",(0,i.jsxs)(t.p,{children:["A last, but extremely useful feature - especially when testing multiple lines of similar formed output - are ",(0,i.jsx)(t.em,{children:"Quantifiers"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Consider the ",(0,i.jsx)(t.code,{children:"curl"})," query from above. It ends in ",(0,i.jsx)(t.code,{children:"?per_page=5"}),", which indicates that we should expect ",(0,i.jsx)(t.em,{children:"up to"})," five items - could be less, though. A different valid scenario would be too much output. Imagine your CLI outputs, say, hundreds or even thousands of lines. That would make any test file unreadable, aka unmaintainable, for humans. A test that cannot be understood is equal to no test - maybe even worse."]}),"\n",(0,i.jsxs)(t.p,{children:["So how would a test look that addresses those issues? Especially when knowing that ",(0,i.jsx)(t.em,{children:"every output line"})," must be covered by an expectation? Enter the ",(0,i.jsx)(t.em,{children:"expectation quantifier"}),", which allows you to define quantities for expectations. Consider this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",children:"## Transform input from live data\n\n```scrut\n$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | \\\n> jq '.[] | .commit.author.name + \";\" + .commit.committer.date'\n*;20*Z (glob+)\n```\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Note the ",(0,i.jsx)(t.code,{children:"+"})," symbol after the ",(0,i.jsx)(t.code,{children:"glob"})," word. That is a quantifier. ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/expectations#quantifiers",children:"Read more about them here"}),". Suffice to say that there are three (",(0,i.jsx)(t.code,{children:"?"})," = optional, ",(0,i.jsx)(t.code,{children:"*"})," = 0 or more, ",(0,i.jsx)(t.code,{children:"+"})," = 1 or more). Meaning, this single line covers all the possible output lines that match this form."]}),"\n",(0,i.jsx)(t.h2,{id:"pattern-structure-by-use-case",children:"Pattern: Structure by use-case"}),"\n",(0,i.jsx)(t.p,{children:"This tutorial already talked about how to structure tests inside a file (having bootstrapping at the top, followed by the actual tests). As a last topic let's talk for a minute about how to structure test files (within folders)."}),"\n",(0,i.jsx)(t.p,{children:"As noted at the start of this document, Scrut can be very useful for CLI owners and system administrators alike. The former may concentrate on testing and documenting a single CLI. The latter may concentrate on testing and documenting the interplay of multiple command line tools at once, maybe the process of a runbook, or a specific operation to recover a database or something like that."}),"\n",(0,i.jsxs)(t.p,{children:["Either way ",(0,i.jsx)(t.strong,{children:"it is good practice to isolate every use-case into a single file"}),". That could be one test file per sub-command of the CLI that is tested or one test file per runbook that is tested. Whatever makes most sense. The purpose should be to gain the most information possible out of a failing test: ",(0,i.jsxs)(t.em,{children:["Test ",(0,i.jsx)(t.code,{children:"A.md"})," is failing, but test ",(0,i.jsx)(t.code,{children:"B.md"})," is not, that indicates that ",(0,i.jsx)(t.code,{children:"feature X"})," is broken"]}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["For ",(0,i.jsx)(t.code,{children:"jq"})," that could mean to write a single ",(0,i.jsx)(t.a,{href:"https://jqlang.github.io/jq/manual/#Builtinoperatorsandfunctions",children:"file per function"})," ",(0,i.jsx)(t.code,{children:"jq"})," exposes. However, if ",(0,i.jsx)(t.code,{children:"jq"})," already has a unittest suite that covers each function, maybe it makes more sense to concentrate on testing ",(0,i.jsx)(t.a,{href:"https://jqlang.github.io/jq/manual/#IO",children:"I/O"})," and also maybe whether ",(0,i.jsx)(t.a,{href:"https://jqlang.github.io/jq/manual/#Modules",children:"modules"})," work as expected."]}),"\n",(0,i.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,i.jsxs)(t.p,{children:["You did it. You are a ",(0,i.jsx)(t.em,{children:"scrutacean"})," now (",(0,i.jsx)(t.a,{href:"https://www.rust-lang.org/",children:"rust"})," developers are called ",(0,i.jsx)(t.em,{children:"rustaceans"}),", scrut is build in rust, there you go). If you want, go ahead and write some additional tests for ",(0,i.jsx)(t.code,{children:"jq"}),", or dig deeper into the rest of ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/file-formats",children:"file formats"}),", ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/expectations",children:"expectations"})," or  ",(0,i.jsx)(t.a,{href:"/scrut/docs/advanced/specifics",children:"behavioral specifics"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);