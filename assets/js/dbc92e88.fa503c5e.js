"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[4510],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>d});var s=n(96540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}},38315:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"reference/fundamentals/test-output","title":"Test Output","description":"Executing a test document with Scrut results either in success (when all expectations in the test match) or failure (when at least one expectation in the test document does not match).","source":"@site/docs/reference/fundamentals/test-output.md","sourceDirName":"reference/fundamentals","slug":"/reference/fundamentals/test-output","permalink":"/scrut/docs/reference/fundamentals/test-output","draft":false,"unlisted":false,"editUrl":"https://www.internalfb.com/code/fbsource/fbcode/clifoundation/scrut/website/docs/reference/fundamentals/test-output.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Test Document","permalink":"/scrut/docs/reference/fundamentals/test-document"},"next":{"title":"Cram Format","permalink":"/scrut/docs/reference/formats/cram-format"}}');var i=n(74848),r=n(28453);const a={},d="Test Output",o={},l=[{value:"Pretty Renderer (default)",id:"pretty-renderer-default",level:2},{value:"Multiline Matches",id:"multiline-matches",level:3},{value:"Diff renderer",id:"diff-renderer",level:2},{value:"JSON and YAML renderer",id:"json-and-yaml-renderer",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"test-output",children:"Test Output"})}),"\n",(0,i.jsx)(t.p,{children:"Executing a test document with Scrut results either in success (when all expectations in the test match) or failure (when at least one expectation in the test document does not match)."}),"\n",(0,i.jsxs)(t.p,{children:["Scrut supports multiple ",(0,i.jsx)(t.em,{children:"output renderers"}),", which yield a different representation of these test results."]}),"\n",(0,i.jsx)(t.h2,{id:"pretty-renderer-default",children:"Pretty Renderer (default)"}),"\n",(0,i.jsx)(t.p,{children:"Scrut will always tell you what it did:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ scrut test selftest/cases/regex.md\n\ud83d\udd0e Found 1 test document(s)\n\nResult: 1 document(s) with 10 testcase(s): 10 succeeded, 0 failed and 0 skipped\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In case of failure the ",(0,i.jsx)(t.code,{children:"pretty"})," default renderer will provide a human-readable output that points you to the problem with the output:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ scrut test a-failing-test.md\n\ud83d\udd0e Found 1 test document(s)\n\u274c /tmp/test.md: failed 1 out of 1 testcase\n\n// =============================================================================\n// @ a-failing-test.md:10\n// -----------------------------------------------------------------------------\n// # One conjunct expression\n// -----------------------------------------------------------------------------\n// $ echo Foo && \\\n//   echo Bar\n// =============================================================================\n\n1  1  |   Foo\n   2  | - BAR\n2     | + Bar\n3     | + Baz\n\n\nResult: 1 document(s) with 1 testcase(s): 0 succeeded, 1 failed and 0 skipped\n"})}),"\n",(0,i.jsx)(t.p,{children:"The failure output consists of two components:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["The failure header, which consists of all initial lines that start with ",(0,i.jsx)(t.code,{children:"//"}),", indicates the position"]}),"\n",(0,i.jsx)(t.li,{children:"The failure body, which consists of all the following lines, indicates the problem"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Header"})}),"\n",(0,i.jsx)(t.p,{children:"The header contains three relevant information. Given the above output:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"@ a-failing-test.md:10"}),", tells you that the test that failed is in the provided document ",(0,i.jsx)(t.code,{children:"a-failing-test.md"})," and that the ",(0,i.jsx)(t.a,{href:"/docs/reference/fundamentals/shell-expression/",children:"shell expression"})," (that failed the test) starts in line ten of that file."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"# <test title>"}),", gives you the optional title of the test in the document. ",(0,i.jsx)(t.em,{children:"If the test does not have a title, this line is omitted."})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$ <test command>"}),", is the ",(0,i.jsx)(t.a,{href:"/docs/reference/fundamentals/shell-expression/",children:"shell expression"})," from the ",(0,i.jsx)(t.a,{href:"/docs/reference/fundamentals/test-document/",children:"test document"})," that is tested and that has failed."]}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["See ",(0,i.jsx)(t.a,{href:"/docs/reference/fundamentals/test-case/",children:"Reference > Fundamentals > Test Case"}),") to learn more about test case anatomy."]})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Body"})}),"\n",(0,i.jsxs)(t.p,{children:["There are two possible variants that the ",(0,i.jsx)(t.code,{children:"diff"})," renderer may return:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Failed ",(0,i.jsx)(t.a,{href:"/docs/reference/fundamentals/output-expectations/",children:"output expectations"})]}),"\n",(0,i.jsxs)(t.li,{children:["Failed ",(0,i.jsx)(t.a,{href:"/docs/reference/behavior/exit-codes/",children:"exit code expectation"})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The above output is a failed ",(0,i.jsx)(t.a,{href:"/docs/reference/fundamentals/output-expectations/",children:"output expectations"})," and you can read it as following:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"1  1  |   Foo"}),": This line was printed as expected. The left hand ",(0,i.jsx)(t.code,{children:"1"})," is the number of the output line and the right hand ",(0,i.jsx)(t.code,{children:"1"})," is the number of the expectation."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"   2  | - BAR"}),": This line was expected, but not printed. The left hand omitted number indicates that it was not found in output. The right hand number tells that this is the second expectation. The ",(0,i.jsx)(t.code,{children:"-"})," before the line ",(0,i.jsx)(t.code,{children:"Bar"})," emphasizes that this is a missed expectation."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"2     | + Bar"}),": This line was printed and expected. The left hand ",(0,i.jsx)(t.code,{children:"2"})," is the number of the output line and the right hand ",(0,i.jsx)(t.code,{children:"3"})," is the number of the expectation."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"3     | + Baz"}),": This line was printed unexpectedly. The left hand ",(0,i.jsx)(t.code,{children:"3"})," is the number of the output line the omitted right hand number implies there is no expectation that covers it. The ",(0,i.jsx)(t.code,{children:"+"})," before the line ",(0,i.jsx)(t.code,{children:"Zoing"}),' emphasizes that this is a "surplus" line.']}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["If you work with test files that contain a large amount of tests, then you may want to use the ",(0,i.jsx)(t.code,{children:"--absolute-line-numbers"})," flag on the command line: instead of printing the relative line number for each test, as described above, it prints absolute line numbers from within the test file. Assuming the ",(0,i.jsx)(t.code,{children:"Foo"})," expectation from above is in line 10 of a file, it would read ",(0,i.jsx)(t.code,{children:"13  13  |   Foo"})," - and all subsequent output liens with respective aligned line numbers."]})}),"\n",(0,i.jsxs)(t.p,{children:["An example for the body of an ",(0,i.jsx)(t.em,{children:"exit code expectation"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"unexpected exit code\n  expected: 2\n  actual:   0\n\n## STDOUT\n#> Foo\n## STDERR\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This should be mostly self-explanatory. Scrut does not provide any ",(0,i.jsx)(t.a,{href:"/docs/reference/fundamentals/output-expectations/",children:"output expectation"})," failures, because it assumes that when the exit code is different, then it is highly likely that the output is very different - and even if not, it would not matter, as it failed anyway."]}),"\n",(0,i.jsxs)(t.p,{children:["The tailing ",(0,i.jsx)(t.code,{children:"## STDOUT"})," and ",(0,i.jsx)(t.code,{children:"## STDERR"})," contain the output lines (prefixed with ",(0,i.jsx)(t.code,{children:"#> "}),") that were printed out from the failed execution."]}),"\n",(0,i.jsx)(t.h3,{id:"multiline-matches",children:"Multiline Matches"}),"\n",(0,i.jsxs)(t.p,{children:["If you use output expectations with a ",(0,i.jsx)(t.a,{href:"/docs/reference/fundamentals/output-expectations/#quantifiers",children:"quantifier"})," that allows for multiline matches then Scrut will print the output lines that match the expectation. For example, consider the following test:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",metastring:'title="some-test.md" showLineNumbers',children:'# Some test\n\n```scrut\n$ echo -e "foo\\nbar1\\nbar2\\nbar3\\nbar4\\nbaz"\nbar* (glob+)\n```\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This test will fail, because ",(0,i.jsx)(t.code,{children:"bar* (glob+)"})," does not mach the first or the last line. The failed output will look like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",metastring:'title="Terminal"',children:'$ scrut test some-test.md\n\ud83d\udd0e Found 1 test document(s)\n\u274c some-test.md: failed 1 out of 1 testcase\n\n// =============================================================================\n// @ some-test.md:4\n// -----------------------------------------------------------------------------\n// # Some test\n// -----------------------------------------------------------------------------\n// $ echo -e "foo\\nbar1\\nbar2\\nbar3\\nbar4\\nbaz"\n// =============================================================================\n\n   1  | + foo\n1+ 2  |   bar1  // bar* (glob+)\n + 3  |   bar2\n + 4  |   bar3\n + 5  |   bar4\n   6  | + baz\n\n\nResult: 1 document(s) with 1 testcase(s): 0 succeeded, 1 failed and 0 skipped\n'})}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsxs)(t.p,{children:["The amount of lines that are printed is controlled by the ",(0,i.jsx)(t.code,{children:"--multiline-match-lines"})," flag. The default is ",(0,i.jsx)(t.code,{children:"100"})," to strike a balance between meaningful output and flooding the terminal. If more lines than that are produced then only the first 50 and last 50 lines are printed, with a hint that there are more lines in between:"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",metastring:'title="Terminal"',children:'$ scrut test --max-multiline-matched-lines=2 some-test.md\n\ud83d\udd0e Found 1 test document(s)\n\u274c some-test.md: failed 1 out of 1 testcase\n\n// =============================================================================\n// @ some-test.md:4\n// -----------------------------------------------------------------------------\n// # Some test\n// -----------------------------------------------------------------------------\n// $ echo -e "foo\\nbar1\\nbar2\\nbar3\\nbar4\\nbaz"\n// =============================================================================\n\n   1  | + foo\n1+ 2  |   bar1  // bar* (glob+)\n +    | \u2026\n + 5  |   bar4\n   6  | + baz\n\n\nResult: 1 document(s) with 1 testcase(s): 0 succeeded, 1 failed and 0 skipped\n'})}),(0,i.jsxs)(t.p,{children:["If you set ",(0,i.jsx)(t.code,{children:"--multiline-match-lines"})," to less or equal ",(0,i.jsx)(t.code,{children:"1"})," then Scrut will not print any lines that match the expectation, but only the expectation itself:"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"   1  | + foo\n1+ +  |   bar* (glob+)\n   6  | + baz\n"})})]}),"\n",(0,i.jsx)(t.h2,{id:"diff-renderer",children:"Diff renderer"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"diff"})," renderer, that can be enabled with ",(0,i.jsx)(t.code,{children:"--renderer diff"})," (or ",(0,i.jsx)(t.code,{children:"-r diff"}),"), prints a diff in the ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Diff#Unified_format",children:"unified format"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ scrut test -r diff a-failing-test.md\n\ud83d\udd0e Found 1 test document(s)\n\u274c a-failing-test.md: failed 1 out of 1 testcase\n\n--- a-failing-test.md\n+++ a-failing-test.md.new\n@@ -14 +14,2 @@ malformed output: One conjunct expression\n-BAR\n+Bar\n+Baz\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["The created diff is compatible with the ",(0,i.jsx)(t.code,{children:"patch"})," command line tool (e.g. ",(0,i.jsx)(t.code,{children:"patch -p0 < <(scrut test -r diff a-failing-test.md)"}),"). This is mostly equivalent to using the ",(0,i.jsx)(t.code,{children:"scrut update"})," command."]})}),"\n",(0,i.jsx)(t.h2,{id:"json-and-yaml-renderer",children:"JSON and YAML renderer"}),"\n",(0,i.jsxs)(t.p,{children:["These renderer are primarily intended for automation and are to be ",(0,i.jsx)(t.strong,{children:"considered experimental"}),".\nYou can explore them using ",(0,i.jsx)(t.code,{children:"--renderer yaml"})," or respective ",(0,i.jsx)(t.code,{children:"--renderer json"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);