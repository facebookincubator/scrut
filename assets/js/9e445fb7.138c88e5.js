"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[2341],{24286:(e,t,n)=>{n.d(t,{Ay:()=>a,RM:()=>r});var i=n(74848),o=n(28453);const r=[];function s(e){return(0,i.jsx)(i.Fragment,{})}function a(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(s,{...e})}):s()}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var i=n(96540);const o={},r=i.createContext(o);function s(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:t},e.children)}},81964:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"tutorial/output-expectations","title":"Output Expectations","description":"Smoke tests are useful for identifying if a program is broken, but they don\'t confirm correct functionality. When running commands manually in the terminal, the initial check for correct operation is through their output: does it match expectations, or are there error messages?","source":"@site/docs/tutorial/04-output-expectations.md","sourceDirName":"tutorial","slug":"/tutorial/output-expectations","permalink":"/scrut/docs/tutorial/output-expectations","draft":false,"unlisted":false,"editUrl":"https://www.internalfb.com/code/fbsource/fbcode/clifoundation/scrut/website/docs/tutorial/04-output-expectations.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Basic Expectations","permalink":"/scrut/docs/tutorial/basic-expectations"},"next":{"title":"Test Environment","permalink":"/scrut/docs/tutorial/test-environment"}}');var o=n(74848),r=n(28453),s=n(24286);const a={},c="Output Expectations",l={},d=[...s.RM,{value:"Output Expectation Types",id:"output-expectation-types",level:2},{value:"Practical Example",id:"practical-example",level:2},{value:"Generalize Output Expectation",id:"generalize-output-expectation",level:3},{value:"Quantifiers for Expectations",id:"quantifiers-for-expectations",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{FbInternalOnly:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("FbInternalOnly",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"output-expectations",children:"Output Expectations"})}),"\n",(0,o.jsx)(n,{children:(0,o.jsx)(s.Ay,{})}),"\n",(0,o.jsx)(t.p,{children:"Smoke tests are useful for identifying if a program is broken, but they don't confirm correct functionality. When running commands manually in the terminal, the initial check for correct operation is through their output: does it match expectations, or are there error messages?"}),"\n",(0,o.jsxs)(t.p,{children:["This is what ",(0,o.jsx)(t.strong,{children:"output expectations"})," are all about."]}),"\n",(0,o.jsx)(t.h2,{id:"output-expectation-types",children:"Output Expectation Types"}),"\n",(0,o.jsxs)(t.p,{children:["The simplest variant of an ",(0,o.jsx)(t.em,{children:"output expectation"})," was already demonstrated previously when the test for the ",(0,o.jsx)(t.code,{children:"jq --version"})," command was created:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-markdown",metastring:"{3}",children:"```scrut\n$ jq --version\njq-1.7.1\n```\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The line that reads ",(0,o.jsx)(t.code,{children:"jq-1.7.1"})," is what Scrut calls a ",(0,o.jsx)(t.em,{children:"equal"})," output expectation. It could also have been written like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-markdown",metastring:"{3}",children:"```scrut\n$ jq --version\njq-1.7.1 (equal)\n```\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The suffix ",(0,o.jsx)(t.code,{children:" (equal)"})," here tells Scrut that the output is expected exactly as written before. There are other types, for example:"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Glob: Match all"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-markdown",metastring:"{3}",children:"```scrut\n$ jq --version\njq-* (glob)\n```\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"*"})," wildcard in ",(0,o.jsx)(t.code,{children:"jq-*"})," matches anything. Scrut would accept any string that starts with ",(0,o.jsx)(t.code,{children:"jq-"}),"."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Regex: Match precisely"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-markdown",metastring:"{3}",children:"```scrut\n$ jq --version\njq-1\\.\\d+\\.\\d+ (regex)\n```\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"1\\.\\d+\\.\\d+"})," regular expression matches any version number that starts with a one and is followed by two numbers, separated by a dot."]}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsxs)(t.p,{children:["Learn more about output expectations in the ",(0,o.jsx)(t.a,{href:"/docs/reference/fundamentals/output-expectations/",children:"Reference > Fundamentals > Output Expectations"})," later."]})}),"\n",(0,o.jsx)(t.h2,{id:"practical-example",children:"Practical Example"}),"\n",(0,o.jsxs)(t.p,{children:["Let's take a look at a practical example. Using ",(0,o.jsx)(t.code,{children:"jq"})," some JSON input data is required. Following the same example as provided in the ",(0,o.jsxs)(t.a,{href:"https://jqlang.org/tutorial/",children:[(0,o.jsx)(t.code,{children:"jq"})," tutorial itself"]}),": Let's go with the Github API."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",metastring:'title="Terminal"',children:'$ curl \'https://api.github.com/repos/jqlang/jq/commits?per_page=5\'\n[\n  {\n    "sha": "947fcbbb1fedbdd6021ef3f93782a500e32d5dcd",\n    "node_id": "C_kwDOAE3WVdoAKDk0N2ZjYmJiMWZlZGJkZDYwMjFlZjNmOTM3ODJhNTAwZTMyZDVkY2Q",\n    "commit": {\n      "author": {\n        "name": "dependabot[bot]",\n        "email": "49699333+dependabot[bot]@users.noreply.github.com",\n        "date": "2025-03-28T00:57:51Z"\n      },\n      "committer": {\n        "name": "GitHub",\n        "email": "noreply@github.com",\n        "date": "2025-03-28T00:57:51Z"\n      },\n      "message": "--%<--",\n      "tree": {\n        "sha": "8b30ae1036b74c4acf02c674f75db8f1ce014aa4",\n        "url": "https://api.github.com/repos/jqlang/jq/git/trees/8b30ae1036b74c4acf02c674f75db8f1ce014aa4"\n      },\n      "url": "https://api.github.com/repos/jqlang/jq/git/commits/947fcbbb1fedbdd6021ef3f93782a500e32d5dcd",\n      "comment_count": 0,\n      "verification": {\n        "verified": true,\n        "reason": "valid",\n        "signature": "--%<--",\n        "payload": "--%<--",\n        "verified_at": "2025-03-28T00:57:55Z"\n      }\n    },\n    "url": "https://api.github.com/repos/jqlang/jq/commits/947fcbbb1fedbdd6021ef3f93782a500e32d5dcd",\n    "html_url": "https://github.com/jqlang/jq/commit/947fcbbb1fedbdd6021ef3f93782a500e32d5dcd",\n    "comments_url": "https://api.github.com/repos/jqlang/jq/commits/947fcbbb1fedbdd6021ef3f93782a500e32d5dcd/comments",\n    "author": {\n--%<--\n'})}),"\n",(0,o.jsxs)(t.p,{children:["That is a lot of output. Let's use ",(0,o.jsx)(t.code,{children:"jq"})," to boil that down into something more manageable. Say, as CSV with the first column the commit date and the second column the author's name:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | \\\n    jq -r '.[] | .commit.committer.date + \",\" + .commit.author.name'\n2025-03-28T00:57:51Z,dependabot[bot]\n2025-03-28T00:56:51Z,dependabot[bot]\n2025-03-28T00:55:39Z,dependabot[bot]\n2025-03-27T23:43:06Z,itchyny\n2025-03-27T23:42:44Z,itchyny\n"})}),"\n",(0,o.jsxs)(t.admonition,{type:"note",children:[(0,o.jsxs)(t.p,{children:["The output you will see when executing the above ",(0,o.jsx)(t.code,{children:"curl"})," command will contain more lines than are shown above:"]}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",metastring:'title="Terminal" {3-5}',children:"$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | \\\n    jq -r '.[] | .commit.committer.date + \",\" + .commit.author.name'\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100 28935  100 28935    0     0   250k      0 --:--:-- --:--:-- --:--:--  250k\n2025-03-28T00:57:51Z,dependabot[bot]\n2025-03-28T00:56:51Z,dependabot[bot]\n2025-03-28T00:55:39Z,dependabot[bot]\n2025-03-27T23:43:06Z,itchyny\n2025-03-27T23:42:44Z,itchyny\n"})}),(0,o.jsxs)(t.p,{children:["The first three lines above that ",(0,o.jsx)(t.code,{children:"curl"})," prints are written to STDERR. Only the actual result content (i.e. the web request body) is printed to STDOUT and piped to ",(0,o.jsx)(t.code,{children:"jq"})," which transforms them into five lines that are finally printed on STDOUT."]}),(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Scrut only considers STDOUT"})," by default. More about how to change this behavior ",(0,o.jsx)(t.a,{href:"/docs/reference/behavior/stdout-and-stderr/",children:"here"}),"."]})]}),"\n",(0,o.jsxs)(t.p,{children:["To go from here to a test either use ",(0,o.jsx)(t.code,{children:"scrut create"})," with the above command, or open a new file and add the commandline and output yourself:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-markdown",metastring:'title="tests/expectations.md"',children:"# Output Expectations\n\n```scrut\n$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | \\\n>   jq -r '.[] | .commit.committer.date + \",\" + .commit.author.name'\n2025-03-28T00:57:51Z,dependabot[bot]\n2025-03-28T00:56:51Z,dependabot[bot]\n2025-03-28T00:55:39Z,dependabot[bot]\n2025-03-27T23:43:06Z,itchyny\n2025-03-27T23:42:44Z,itchyny\n```\n"})}),"\n",(0,o.jsxs)(t.admonition,{type:"note",children:[(0,o.jsxs)(t.p,{children:["Shell expressions that span multiple lines need to be prefixed with a ",(0,o.jsx)(t.code,{children:">"}),", like so:"]}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-markdown",children:"```scrut\n$ line 1\n> line 2\n> line N\n```\n"})}),(0,o.jsxs)(t.p,{children:["The whole expression will then be piped into a bash process and executed. If you do not concatenate the lines with something ",(0,o.jsx)(t.code,{children:"&&"})," or explicitly ",(0,o.jsx)(t.code,{children:"set -e"}),", then the exit code will be from the last executed line."]}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-markdown",children:"```scrut\n$ line 1 && \\\n> line 2 && \\\n> line N\n```\n"})})]}),"\n",(0,o.jsx)(t.h3,{id:"generalize-output-expectation",children:"Generalize Output Expectation"}),"\n",(0,o.jsxs)(t.p,{children:["Running ",(0,o.jsx)(t.code,{children:"scrut test tests/expectations.md"})," right after creating the file should succeed. ",(0,o.jsx)(t.em,{children:"Should"}),", because the output is not stable. It is not guaranteed to be the same tomorrow, or even in a few minutes. To make it more stable the test can be changed:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["from ",(0,o.jsx)(t.em,{children:"with the JSON input from the github API this exact output is expected"})]}),"\n",(0,o.jsxs)(t.li,{children:["to ",(0,o.jsx)(t.em,{children:"with the JSON input from the github API 5 lines separated by a comma are expected"})]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-markdown",metastring:"{4-8}",children:"```scrut\n$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | \\\n>   jq -r '.[] | .commit.committer.date + \",\" + .commit.author.name'\n*,* (glob)\n*,* (glob)\n*,* (glob)\n*,* (glob)\n*,* (glob)\n```\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Obviously this test lost precision compared to the previous variant, but on the plus side: it won't break as easy, it is still meaningful and it could break if, say, the ",(0,o.jsx)(t.code,{children:"jq"})," concatenate operator ",(0,o.jsx)(t.code,{children:"+"})," malfunctions. This could be made more precise using ",(0,o.jsx)(t.code,{children:"20*T*Z,* (glob)"})," to account for the date string, or even use matching ",(0,o.jsx)(t.code,{children:"regex"})," rules."]}),"\n",(0,o.jsx)(t.h3,{id:"quantifiers-for-expectations",children:"Quantifiers for Expectations"}),"\n",(0,o.jsx)(t.p,{children:"The above test could be generalized further. While it probably would not make sense for this case the following would work as well:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-markdown",metastring:"{4}",children:"```scrut\n$ curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | \\\n>   jq -r '.[] | .commit.committer.date + \",\" + .commit.author.name'\n*,* (glob+)\n```\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Note the ",(0,o.jsx)(t.code,{children:"+"})," behind the word ",(0,o.jsx)(t.code,{children:"glob"}),". This is a ",(0,o.jsx)(t.strong,{children:"quantifier"}),". Quantifiers can be used with any output expectation. They make sense when a hard to predict amount of predictable formatted output needs to be accounted for."]}),"\n",(0,o.jsxs)(t.admonition,{type:"note",children:[(0,o.jsx)(t.p,{children:"Scrut currently understands three quantifiers:"}),(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"?"}),": Zero or one"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"*"}),": Any amount, including zero"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"+"}),": Any amount, but at least one"]}),"\n"]}),(0,o.jsxs)(t.p,{children:["More detail in ",(0,o.jsx)(t.a,{href:"/docs/reference/fundamentals/output-expectations/#quantifiers",children:"Reference > Fundamentals > Output Expectations > Quantifiers"}),"."]})]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);