"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[5845],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var l=t(96540);const s={},o=l.createContext(s);function i(e){const n=l.useContext(o);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),l.createElement(o.Provider,{value:n},e.children)}},39140:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});const l=JSON.parse('{"id":"reference/fundamentals/output-expectations","title":"Output Expectations","description":"Output expectations are predictions of one or more lines of output. What you think a command will print out when you execute it. My expectation when I execute uname is that the operating system name is printed out to the shell. On a mac, I expect the following:","source":"@site/docs/reference/fundamentals/output-expectations.md","sourceDirName":"reference/fundamentals","slug":"/reference/fundamentals/output-expectations","permalink":"/scrut/docs/reference/fundamentals/output-expectations","draft":false,"unlisted":false,"editUrl":"https://www.internalfb.com/code/fbsource/fbcode/clifoundation/scrut/website/docs/reference/fundamentals/output-expectations.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Inline Configuration","permalink":"/scrut/docs/reference/fundamentals/inline-configuration"},"next":{"title":"Shell Expressions","permalink":"/scrut/docs/reference/fundamentals/shell-expression"}}');var s=t(74848),o=t(28453);const i={},r="Output Expectations",d={},c=[{value:"Quantifiers",id:"quantifiers",level:2},{value:"Equal Expectation",id:"equal-expectation",level:2},{value:"Examples",id:"examples",level:3},{value:"Equal No EOL Expectation",id:"equal-no-eol-expectation",level:2},{value:"Examples",id:"examples-1",level:3},{value:"Glob Expectation",id:"glob-expectation",level:2},{value:"Examples",id:"examples-2",level:3},{value:"Regex Expectation",id:"regex-expectation",level:2},{value:"Examples",id:"examples-3",level:3},{value:"Escaped Expectation",id:"escaped-expectation",level:2},{value:"Examples",id:"examples-4",level:3},{value:"Escaped Glob Expectations",id:"escaped-glob-expectations",level:3},{value:"Edge-Case: Output vs Expectations",id:"edge-case-output-vs-expectations",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"output-expectations",children:"Output Expectations"})}),"\n",(0,s.jsxs)(n.p,{children:["Output expectations are predictions of one or more lines of output. ",(0,s.jsx)(n.em,{children:"What you think a command will print out when you execute it"}),". My expectation when I execute ",(0,s.jsx)(n.code,{children:"uname"})," is that the operating system name is printed out to the shell. On a mac, I expect the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ uname\nDarwin\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Understand how Scrut deals with ",(0,s.jsx)(n.a,{href:"/docs/reference/behavior/stdout-and-stderr/",children:"STDOUT and STDERR"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"The Backus-Naur form for output expectations is sweet and short:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bnf",children:' <expectation> ::= <expression> | <expression> (<mod>)\n  <expression> ::= TEXT\n         <mod> ::= <kind> | <quantifier> | <kind><quantifier>\n        <kind> ::= <equal-kind> | <no-eol-kind> | <escaped-kind> | <glob-kind> | <regex-kind>\n  <equal-kind> ::= "equal" | "eq"\n <no-eol-kind> ::= "no-eol"\n<escaped-kind> ::= "escaped" | "esc"\n   <glob-kind> ::= "glob" | "gl"\n  <regex-kind> ::= "regex" | "re"\n  <quantifier> ::= "?" | "*" | "+"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"quantifiers",children:"Quantifiers"}),"\n",(0,s.jsx)(n.p,{children:"The Quantifiers can be understood as following (nothing new if you are familiar with regular expressions):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"?"})}),": Zero or one occurrence; basically an optional output line"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"*"})}),": Any amount of occurrences (",(0,s.jsx)(n.code,{children:"0..n"}),"); no line, one line, more lines - all good"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"+"})}),": One or more occurrences (",(0,s.jsx)(n.code,{children:"1..n"}),"); at least one line, more are fine"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Quantifiers can be used with most expectations, see the examples and description below for more details."}),"\n",(0,s.jsx)(n.h2,{id:"equal-expectation",children:"Equal Expectation"}),"\n",(0,s.jsxs)(n.p,{children:["The Equal Expectation denotes a single line of output that ends in a ",(0,s.jsx)(n.a,{href:"/docs/reference/behavior/newline-handling/",children:"newline character"}),". Because this expectation is the most common one you do not need to provide the specific kind. Here an example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:"showLineNumbers",children:"# Some Test\n\n```scrut\n$ echo Hello\nHello\n```\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The line that consists only of ",(0,s.jsx)(n.code,{children:"Hello"})," ",(0,s.jsx)(n.em,{children:"is"})," the Equal Expectation and specifies that the (first line of the) output must be equal to ",(0,s.jsx)(n.code,{children:"Hello\\n"})," (with ",(0,s.jsx)(n.code,{children:"\\n"})," being the ",(0,s.jsx)(n.a,{href:"/docs/reference/behavior/newline-handling/",children:"newline of the operating system"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"An extended for of the same Equal Expectation with explicit kind works as well and looks like that:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:"showLineNumbers",children:"# Some Test\n\n```scrut\n$ echo Hello\nHello (equal)\n```\n"})}),"\n",(0,s.jsx)(n.p,{children:"The explicit form makes most sense in conjunction with quantifiers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:"showLineNumbers",children:'# Some Test\n\n```scrut\n$ echo -e "Hello\\nHello\\nHello"\nHello (equal+)\n```\n'})}),"\n",(0,s.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello"})}),(0,s.jsxs)(n.td,{children:["One output line of the form ",(0,s.jsx)(n.code,{children:"Hello\\n"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello (equal)"})}),(0,s.jsxs)(n.td,{children:["One output line of the form ",(0,s.jsx)(n.code,{children:"Hello\\n"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello (?)"})}),(0,s.jsxs)(n.td,{children:["Optional (zero or one) output line of the form ",(0,s.jsx)(n.code,{children:"Hello\\n"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello (*)"})}),(0,s.jsxs)(n.td,{children:["Any amount (0..n) of output lines of the form ",(0,s.jsx)(n.code,{children:"Hello\\n"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello (+)"})}),(0,s.jsxs)(n.td,{children:["One or more (1..n) of output lines of the form ",(0,s.jsx)(n.code,{children:"Hello\\n"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello (equal*)"})}),(0,s.jsxs)(n.td,{children:["Any amount (0..n) of output lines of the form ",(0,s.jsx)(n.code,{children:"Hello\\n"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello (equal+)"})}),(0,s.jsxs)(n.td,{children:["One or more (1..n) of output lines of the form ",(0,s.jsx)(n.code,{children:"Hello\\n"})]})]})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"eq"})," as a shorthand for ",(0,s.jsx)(n.code,{children:"equal"})]})}),"\n",(0,s.jsx)(n.h2,{id:"equal-no-eol-expectation",children:"Equal No EOL Expectation"}),"\n",(0,s.jsxs)(n.p,{children:["Very close to the above, but much rarer, the ",(0,s.jsx)(n.em,{children:"Equal No EOL Expectation"})," matches lines that do ",(0,s.jsx)(n.em,{children:"not"})," end in a newline. Consider:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:"showLineNumbers",children:"# Some Test\n\n```scrut\n$ echo -n Hello\nHello (no-eol)\n```\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The above ",(0,s.jsx)(n.code,{children:"echo -n Hello"})," prints ",(0,s.jsx)(n.code,{children:"Hello"})," ",(0,s.jsx)(n.em,{children:"without"})," a tailing newline character (there is no ",(0,s.jsx)(n.code,{children:"\\n"})," at the end of ",(0,s.jsx)(n.code,{children:"Hello"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"This Expectation could possibly only be the last line of output, so quantifiers make little sense."}),"\n",(0,s.jsx)(n.h3,{id:"examples-1",children:"Examples"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello (no-eol)"})}),(0,s.jsxs)(n.td,{children:["One output line of the form ",(0,s.jsx)(n.code,{children:"Hello"})," - a line that does not end in newline"]})]})})]}),"\n",(0,s.jsx)(n.h2,{id:"glob-expectation",children:"Glob Expectation"}),"\n",(0,s.jsx)(n.p,{children:"Glob Expectations are support two wildcard characters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"?"})," matches exactly one occurrence of any character"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"*"})," matches arbitrary many (including zero) occurrences of any character"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Together with quantifiers, this allows for powerful if imprecise matches of output lines."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:"showLineNumbers",children:'# This will work\n\n```scrut\n$ echo Hello You\nHello* (glob)\n```\n\nThis will work, too\n\n```scrut\n$ echo -e "Hello\\nHello There\\nHello World"\nHello* (glob+)\n```\n'})}),"\n",(0,s.jsx)(n.h3,{id:"examples-2",children:"Examples"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello? (glob)"})}),(0,s.jsxs)(n.td,{children:["A single output line that starts with ",(0,s.jsx)(n.code,{children:"Hello"})," followed by one character"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello* (glob)"})}),(0,s.jsxs)(n.td,{children:["A single output line that starts with ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"*Hello* (glob)"})}),(0,s.jsxs)(n.td,{children:["A single output line that contains ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"*Hello (glob)"})}),(0,s.jsxs)(n.td,{children:["A single output line that ends with ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"*Hello* (glob?)"})}),(0,s.jsxs)(n.td,{children:["An optional output line that contains ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"*Hello* (glob*)"})}),(0,s.jsxs)(n.td,{children:["Any amount (0..n) of output lines that contain ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"*Hello* (glob+)"})}),(0,s.jsxs)(n.td,{children:["One or more (1..n) of output lines that contain ",(0,s.jsx)(n.code,{children:"Hello"})]})]})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["You can use ",(0,s.jsx)(n.code,{children:"gl"})," as a shorthand for ",(0,s.jsx)(n.code,{children:"glob"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Escaping, like ",(0,s.jsx)(n.code,{children:"Hello\\* * (glob)"}),", is not supported by the ",(0,s.jsx)(n.a,{href:"https://crates.io/crates/wildmatch",children:"used library"}),"."]}),"\n"]})}),"\n",(0,s.jsx)(n.h2,{id:"regex-expectation",children:"Regex Expectation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Regular_expression",children:"Regular Expressions"})," are the most powerful and precise output describing rules that are supported. That comes at the price of complexity. Explaining regular expression syntax literally ",(0,s.jsx)(n.a,{href:"https://www.goodreads.com/search?q=Regular+Expression",children:"fills books"}),", so here is not the place to attempt that."]}),"\n",(0,s.jsx)(n.p,{children:"Nonetheless, an obligatory example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:"showLineNumbers",children:'# This will work\n\n```scrut\n$ echo Hello You\nHello.+ (regex)\n```\n\nThis will work, too:\n\n```scrut\n$ echo -e "Hello\\nEnding in Hello\\nHello Start"\n.*Hello.* (regex+)\n```\n'})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["All Regex Expectations are implicitly embedded within start and end markers: ",(0,s.jsx)(n.code,{children:"^<expression>$"}),". This means ",(0,s.jsx)(n.em,{children:"regular expressions are always assumed to match the full line"}),". Use ",(0,s.jsx)(n.code,{children:".*"})," to explicitly match only at the end of (",(0,s.jsx)(n.code,{children:".*<expression> (regex)"}),"), or the start of (",(0,s.jsx)(n.code,{children:"<expression>.* (regex)"}),"), or anywhere in (",(0,s.jsx)(n.code,{children:".*<expression>.* (regex)"}),") a line."]}),(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"regex"})," Rust library that Scrut uses is an ",(0,s.jsx)(n.a,{href:"https://github.com/google/re2/wiki",children:"RE2"})," inspired engine with a very similar ",(0,s.jsx)(n.a,{href:"https://docs.rs/regex/latest/regex/#syntax",children:"syntax"}),". It most notably differs from Perl's ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions",children:"PCRE"})," in that it doesn't support backtracking (look-around) to ensure good performance."]})]}),"\n",(0,s.jsx)(n.h3,{id:"examples-3",children:"Examples"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello.* (regex)"})}),(0,s.jsxs)(n.td,{children:["A single output line that starts with ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".*Hello.* (regex)"})}),(0,s.jsxs)(n.td,{children:["A single output line that contains ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".*Hello (regex)"})}),(0,s.jsxs)(n.td,{children:["A single output line that ends with ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".*Hello.* (regex?)"})}),(0,s.jsxs)(n.td,{children:["An optional output line that contains ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".*Hello.* (regex*)"})}),(0,s.jsxs)(n.td,{children:["Any amount (0..n) of output lines that contain ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".*Hello.* (regex+)"})}),(0,s.jsxs)(n.td,{children:["One or more (1..n) of output lines that contain ",(0,s.jsx)(n.code,{children:"Hello"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Foo: [0-9]+ (regex+)"})}),(0,s.jsxs)(n.td,{children:["One or more (1..n) of output lines that start with ",(0,s.jsx)(n.code,{children:"Foo"})," followed by a colon ",(0,s.jsx)(n.code,{children:":"}),", a whitespace ",(0,s.jsx)(n.code,{children:" "})," and then only numbers till the end of the line"]})]})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"re"})," as a shorthand for ",(0,s.jsx)(n.code,{children:"regex"})]})}),"\n",(0,s.jsx)(n.h2,{id:"escaped-expectation",children:"Escaped Expectation"}),"\n",(0,s.jsxs)(n.p,{children:["CLIs usually only do (and mostly should) print out, well, printable characters. However, there are scenarios where you need to write binary data to STDOUT. More commonly you will encounter ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/ANSI_escape_code",children:"ANSI escape sequences"})," for color coding and so forth. Lastly, consider the good old tab character ",(0,s.jsx)(n.code,{children:"\\t"}),", which may be hard to read (or write) in a text editor."]}),"\n",(0,s.jsxs)(n.p,{children:["Scrut tests live in text documents that are intended to be edited by users. They should not contain binary. To that end, any non-printable output can be denoted in it's hexadecimal escaped form ",(0,s.jsx)(n.code,{children:"\\xAB"})," (with ",(0,s.jsx)(n.code,{children:"AB"})," being the hexadecimal value of the bytecode of the character) or ",(0,s.jsx)(n.code,{children:"\\t"})," to denote tab characters."]}),"\n",(0,s.jsx)(n.p,{children:"The following example shows an expectation of a string that renders as a bold, red font on the command line"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:"showLineNumbers",children:"# Colorful Fun\n\n```scrut\n$ echo -e 'Foo \\033[1;31mBar\\033[0m Baz'\nFoo \\x1b[1mBar\\x1b[0m Baz (escaped)\n```\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Or consider some program that prints out two ",(0,s.jsx)(n.code,{children:"\\x00"})," separated strings:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:"showLineNumbers",children:"# Colorful Fun\n\n```scrut\n$ some-program\nfoo\\x00bar (escaped)\n```\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or again, the good old tab character:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:"showLineNumbers",children:"# Love the CSV\n\n```scrut\n$ csv-generator\nfoo\\tbar\\tbaz (escaped)\n```\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Newlines are ignored for Escaped Expectations. So ",(0,s.jsx)(n.code,{children:"foo\\tbar (escaped)"})," matches both ",(0,s.jsx)(n.code,{children:"foo\\tbar\\n"})," and ",(0,s.jsx)(n.code,{children:"foo\\tbar"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"examples-4",children:"Examples"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello\\tWorld (escaped)"})}),(0,s.jsxs)(n.td,{children:["One output line of that starts with ",(0,s.jsx)(n.code,{children:"Hello"}),", followed by a tab character, followed by ",(0,s.jsx)(n.code,{children:"World"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello\\tWorld (escaped?)"})}),(0,s.jsxs)(n.td,{children:["An optional output line that contains ",(0,s.jsx)(n.code,{children:"Hello"}),", followed by a tab character, followed by ",(0,s.jsx)(n.code,{children:"World"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello\\tWorld (escaped*)"})}),(0,s.jsxs)(n.td,{children:["Any amount (0..n) of output lines that contain ",(0,s.jsx)(n.code,{children:"Hello\\tWorld"}),", followed by a tab character, followed by ",(0,s.jsx)(n.code,{children:"World"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello\\tWorld (escaped+)"})}),(0,s.jsxs)(n.td,{children:["One or more (1..n) of output lines that contain ",(0,s.jsx)(n.code,{children:"Hello\\tWorld"}),", followed by a tab character, followed by ",(0,s.jsx)(n.code,{children:"World"})]})]})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"esc"})," as a shorthand for ",(0,s.jsx)(n.code,{children:"escaped"})]})}),"\n",(0,s.jsx)(n.h3,{id:"escaped-glob-expectations",children:"Escaped Glob Expectations"}),"\n",(0,s.jsxs)(n.p,{children:["Because it came up often enough, you can use ",(0,s.jsx)(n.code,{children:"(escaped)"})," in combination with ",(0,s.jsx)(n.code,{children:"(glob)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:"showLineNumbers",children:"# Glob Escaped Output\n\n```scrut\n$ csv-generator\nfoo\\t* (escaped) (glob+)\nbar\\tbaz (escaped)\n```\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The above exports one or more lines of output that start with ",(0,s.jsx)(n.code,{children:"foo"})," followed by tab. The last line of output is expected to be ",(0,s.jsx)(n.code,{children:"bar"}),", followed by tab, followed by ",(0,s.jsx)(n.code,{children:"baz"}),"."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello\\tWorld* (escaped) (glob)"})}),(0,s.jsxs)(n.td,{children:["One output line of that starts with ",(0,s.jsx)(n.code,{children:"Hello"}),", followed by a tab character, followed by ",(0,s.jsx)(n.code,{children:"World"}),", followed by anything"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello\\tWorld* (escaped) (glob?)"})}),(0,s.jsxs)(n.td,{children:["An optional output line that contains ",(0,s.jsx)(n.code,{children:"Hello"}),", followed by a tab character, followed by ",(0,s.jsx)(n.code,{children:"World"}),", followed by anything"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello\\tWorld* (escaped) (glob*)"})}),(0,s.jsxs)(n.td,{children:["Any amount (0..n) of output lines that contain ",(0,s.jsx)(n.code,{children:"Hello\\tWorld"}),", followed by a tab character, followed by ",(0,s.jsx)(n.code,{children:"World"}),", followed by anything"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Hello\\tWorld* (escaped) (glob+)"})}),(0,s.jsxs)(n.td,{children:["One or more (1..n) of output lines that contain ",(0,s.jsx)(n.code,{children:"Hello\\tWorld"}),", followed by a tab character, followed by ",(0,s.jsx)(n.code,{children:"World"}),", followed by anything"]})]})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["You can use shorthands for either. Quantifiers must be always on ",(0,s.jsx)(n.code,{children:"glob"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"edge-case-output-vs-expectations",children:"Edge-Case: Output vs Expectations"}),"\n",(0,s.jsx)(n.p,{children:"You may run into a case where you CLI output actually contains an a string that resembles an output expectation kind. For example, consider the following output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="Output"',children:"$ my-cli --some arg\nHello (equal)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"(equal)"})," part above is part of the output of the CLI, not an output expectation of the kind ",(0,s.jsx)(n.code,{children:"equal"}),". To account for that simply be specific with the rules. The following validates the output of the above execution:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",metastring:'title="tests/validate-output.md" showLineNumbers',children:"# Some Test that accounts for output expectations in output\n\n```scrut\n$ my-cli --some arg\nHello (equal) (equal)\n```\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The string ",(0,s.jsx)(n.code,{children:"Hello (equal) (equal)"})," will be read by Scrut as following:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["This is an equal output expectation, as signified by the suffix ",(0,s.jsx)(n.code,{children:" (equal)"})]}),"\n",(0,s.jsxs)(n.li,{children:['The expected output, that precedes the "kind notation", is ',(0,s.jsx)(n.code,{children:"Hello (equal)"})]}),"\n",(0,s.jsxs)(n.li,{children:["If the output of the ",(0,s.jsx)(n.code,{children:"my-cli --some arg"})," is exactly ",(0,s.jsx)(n.code,{children:"Hello (equal)"}),", then the test passes"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Meaning: By giving Scrut the explicit ",(0,s.jsx)(n.code,{children:" (equal)"})," suffix, it will be able to distinguish between the output expectation and the output itself."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);