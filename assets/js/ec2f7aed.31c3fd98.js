"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[132],{24286:(e,t,n)=>{n.d(t,{Ay:()=>r,RM:()=>o});var s=n(74848),i=n(28453);const o=[];function c(e){return(0,s.jsx)(s.Fragment,{})}function r(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c()}},28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>r});var s=n(96540);const i={},o=s.createContext(i);function c(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(o.Provider,{value:t},e.children)}},74510:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"tutorial/test-maintenance","title":"Test Maintenance","description":"Tests are dynamic and require ongoing maintenance due to changes in CLI functionality or dependencies. In Scrut test documents, even if shell expressions remain constant, output expectations may need updates. Or sometimes shell expression must be changed which yield different output. The scrut update command simplifies this process by automatically updating invalid output expectations.","source":"@site/docs/tutorial/08-test-maintenance.md","sourceDirName":"tutorial","slug":"/tutorial/test-maintenance","permalink":"/scrut/docs/tutorial/test-maintenance","draft":false,"unlisted":false,"editUrl":"https://www.internalfb.com/code/fbsource/fbcode/clifoundation/scrut/website/docs/tutorial/08-test-maintenance.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Test Bootstrapping","permalink":"/scrut/docs/tutorial/test-bootstrapping"},"next":{"title":"Next Up","permalink":"/scrut/docs/tutorial/next-up"}}');var i=n(74848),o=n(28453),c=n(24286);const r={},a="Test Maintenance",d={},l=[...c.RM,{value:"Update Tests automatically",id:"update-tests-automatically",level:2}];function u(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components},{FbInternalOnly:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("FbInternalOnly",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"test-maintenance",children:"Test Maintenance"})}),"\n",(0,i.jsx)(n,{children:(0,i.jsx)(c.Ay,{})}),"\n",(0,i.jsxs)(t.p,{children:["Tests are dynamic and require ongoing maintenance due to changes in CLI functionality or dependencies. In Scrut test documents, even if ",(0,i.jsx)(t.em,{children:"shell expressions"})," remain constant, ",(0,i.jsx)(t.em,{children:"output expectations"})," may need updates. Or sometimes ",(0,i.jsx)(t.em,{children:"shell expression"})," must be changed which yield different output. The ",(0,i.jsx)(t.code,{children:"scrut update"})," command simplifies this process by automatically updating invalid output expectations."]}),"\n",(0,i.jsx)(t.h2,{id:"update-tests-automatically",children:"Update Tests automatically"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"scrut update"})," command can be run on one or multiple test documents to re-execute tests and automatically update the ",(0,i.jsx)(t.em,{children:"output expectations"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["For instance, consider the ",(0,i.jsx)(t.code,{children:"smoke.md"})," document, now renamed to ",(0,i.jsx)(t.code,{children:"version-test.md"}),". Previously considered a smoke test, let's treat it as a test for the CLI output for now:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",metastring:'title="tests/version-test.md" showLineNumbers',children:"# Command executes successfully\n\n```scrut\n$ jq --version\njq-1.7.1\n```\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Let's say it was written in the past with an earlier version of ",(0,i.jsx)(t.code,{children:"jq"}),", hence it looks like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-markdown",metastring:'title="tests/version-test.md" showLineNumbers {5}',children:"# Command executes successfully\n\n```scrut\n$ jq --version\njq-1.7.0\n```\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now executing this test with the ",(0,i.jsx)(t.code,{children:"jq"})," version ",(0,i.jsx)(t.code,{children:"1.7.1"})," will fail:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ scrut test tests/version-test.md\n\ud83d\udd0e Found 1 test document(s)\n\u274c tests/version-test.md: failed 1 out of 1 testcase\n\n// =============================================================================\n// @ tests/version-test.md:4\n// -----------------------------------------------------------------------------\n// # Command executes successfully\n// -----------------------------------------------------------------------------\n// $ jq --version\n// =============================================================================\n\n1     | - jq-1.7.0\n   1  | + jq-1.7.1\n\n\nResult: 1 document(s) with 1 testcase(s): 0 succeeded, 1 failed and 0 skipped\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As expected, the version strings do not match and the Scrut test fails. Now, now can obviously straighten that out speedily with a text editor by just changing ",(0,i.jsx)(t.code,{children:"jq-1.7.0"})," to ",(0,i.jsx)(t.code,{children:"jq-1.7.1"}),", or by using ",(0,i.jsx)(t.code,{children:"glob"})," or ",(0,i.jsx)(t.code,{children:"regex"})," expectations. However, if you had tens of test files this would quickly become an annoying chore."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"scrut update"})," command is a better way."]}),"\n",(0,i.jsx)(t.p,{children:"What it does is simply this:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Execute all tests, the same way ",(0,i.jsx)(t.code,{children:"scrut test"})," would"]}),"\n",(0,i.jsx)(t.li,{children:"For any that is invalid (i.e. that has output expectations that do not validate anymore) it offers you to write an updated test with fixed output expectations."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Here is how that looks in practice:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",metastring:'title="Terminal"',children:"$ scrut update --replace tests/version-test.md\n\ud83d\udd0e Found 1 test document(s)\n// @ tests/version-test.md:4\n// -----------------------------------------------------------------------------\n// # Command executes successfully\n// -----------------------------------------------------------------------------\n// $ jq --version\n// =============================================================================\n\n1     | - jq-1.7.0\n   1  | + jq-1.7.1\n\n\n? Overwrite existing document tests/version-test.md? (y/n) \u203a no\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The above is an interactive dialog and waits for user input whether to overwrite the existing file. If consent is given then it would overwrite ",(0,i.jsx)(t.code,{children:"tests/version-test.md"})," with the output that was received from executing ",(0,i.jsx)(t.code,{children:"jq --version"}),"."]}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsxs)(t.p,{children:["Useful parameters for ",(0,i.jsx)(t.code,{children:"scrut update"})," are:"]}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"--replace"})," or ",(0,i.jsx)(t.code,{children:"-r"}),", which writes the updated document into the same location as the original file. If not set then a file ",(0,i.jsx)(t.code,{children:"<document-path>.new"})," will be created."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"--assume-yes"})," or ",(0,i.jsx)(t.code,{children:"-y"}),", which skips the confirmation and always assumes yes"]}),"\n"]}),(0,i.jsxs)(t.p,{children:["Check out ",(0,i.jsx)(t.code,{children:"scrut update --help"})," for additional parameters."]})]}),"\n",(0,i.jsxs)(t.admonition,{type:"warning",children:[(0,i.jsxs)(t.p,{children:["There are limits to what ",(0,i.jsx)(t.code,{children:"scrut update"})," can do:"]}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Only ",(0,i.jsx)(t.code,{children:"equal"})," and ",(0,i.jsx)(t.code,{children:"escaped"})," expectations can be updated, but ",(0,i.jsx)(t.code,{children:"glob"})," and ",(0,i.jsx)(t.code,{children:"regex"})," would be replaced with either ",(0,i.jsx)(t.code,{children:"equal"})," or ",(0,i.jsx)(t.code,{children:"escaped"}),", whichever fits."]}),"\n",(0,i.jsxs)(t.li,{children:["Quantifiers (",(0,i.jsx)(t.code,{children:"*"}),", ",(0,i.jsx)(t.code,{children:"+"}),", ",(0,i.jsx)(t.code,{children:"?"}),") will not be considered: If an output expectation uses quantifiers and became invalid, then ",(0,i.jsx)(t.code,{children:"scrut update"}),' would write individual output expectations instead of one "quantified" expectation.']}),"\n",(0,i.jsx)(t.li,{children:"Prepended and appended test documents are not updated (but you can update them individually)"}),"\n"]})]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);